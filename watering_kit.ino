#include <Wire.h>
#include "U8glib.h"
#include "RTClib.h"

U8GLIB_SSD1306_128X64 u8g(U8G_I2C_OPT_NONE); // I2C OLED
RTC_DS1307 RTC;

// Moisture sensor pins
int moisture1 = A0;
int moisture2 = A1;
int moisture3 = A2;
int moisture4 = A3;

// Raw averaged values (kept for internal use)
int moisture1_raw = 0;
int moisture2_raw = 0;
int moisture3_raw = 0;
int moisture4_raw = 0;

// Mapped percentage values (0-100)
int moisture1_value = 0;
int moisture2_value = 0;
int moisture3_value = 0;
int moisture4_value = 0;

// Sensor validity flags
bool sensor_active[4] = {true, true, true, true};

// Relay and pump pins
int relay1 = 6;
int relay2 = 8;
int relay3 = 9;
int relay4 = 10;
int pump = 4;

// Button
int button = 12;
int lastButtonState = LOW;
unsigned long lastDebounceTime = 0;
const unsigned long debounceDelay = 50;

// Relay states
int relay1_state_flag = 0;
int relay2_state_flag = 0;
int relay3_state_flag = 0;
int relay4_state_flag = 0;
int pump_state_flag = 0;

// Display optimization
int lastMoisture1 = -1, lastMoisture2 = -1, lastMoisture3 = -1, lastMoisture4 = -1;
unsigned long lastDisplayUpdate = 0;
const unsigned long displayInterval = 1000;

// Days of the week
char daysOfTheWeek[7][12] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};

// Bitmaps (good/bad flower and Elecrow logo unchanged)
unsigned char bitmap_good[] U8G_PROGMEM = {
  0x00, 0x42, 0x4C, 0x00, 0x00, 0xE6, 0x6E, 0x00, 0x00, 0xAE, 0x7B, 0x00, 0x00, 0x3A, 0x51, 0x00,
  0x00, 0x12, 0x40, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x06, 0x40, 0x00, 0x00, 0x06, 0x40, 0x00,
  0x00, 0x04, 0x60, 0x00, 0x00, 0x0C, 0x20, 0x00, 0x00, 0x08, 0x30, 0x00, 0x00, 0x18, 0x18, 0x00,
  0x00, 0xE0, 0x0F, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x02, 0xC1, 0x00, 0x00, 0x0E, 0x61, 0x00,
  0x00, 0x1C, 0x79, 0x00, 0x00, 0x34, 0x29, 0x00, 0x00, 0x28, 0x35, 0x00, 0x00, 0x48, 0x17, 0x00,
  0x00, 0xD8, 0x1B, 0x00, 0x00, 0x90, 0x1B, 0x00, 0x00, 0xB0, 0x09, 0x00, 0x00, 0xA0, 0x05, 0x00,
  0x00, 0xE0, 0x07, 0x00, 0x00, 0xC0, 0x03, 0x00
};

unsigned char bitmap_bad[] U8G_PROGMEM = {
  0x00, 0x80, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0xE0, 0x0D, 0x00, 0x00, 0xA0, 0x0F, 0x00,
  0x00, 0x20, 0x69, 0x00, 0x00, 0x10, 0x78, 0x02, 0x00, 0x10, 0xC0, 0x03, 0x00, 0x10, 0xC0, 0x03,
  0x00, 0x10, 0x00, 0x01, 0x00, 0x10, 0x80, 0x00, 0x00, 0x10, 0xC0, 0x00, 0x00, 0x30, 0x60, 0x00,
  0x00, 0x60, 0x30, 0x00, 0x00, 0xC0, 0x1F, 0x00, 0x00, 0x60, 0x07, 0x00, 0x00, 0x60, 0x00, 0x00,
  0x00, 0x60, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xC7, 0x1C, 0x00,
  0x80, 0x68, 0x66, 0x00, 0xC0, 0x33, 0x7B, 0x00, 0x40, 0xB6, 0x4D, 0x00, 0x00, 0xE8, 0x06, 0x00,
  0x00, 0xF0, 0x03, 0x00, 0x00, 0xE0, 0x00, 0x00
};

static unsigned char bitmap_logo[] U8G_PROGMEM = { /* same as before - unchanged */ 
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0xE0,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x04,0xF8,0xFF,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x08,0xFE,0xFF,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x10,0x1F,0xE0,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0xB0,0x07,0x80,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0xE0,0x03,0x00,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x60,0x23,0x00,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x70,0xC7,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x70,0x9E,0x0F,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x70,0x3C,0xFE,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x70,0x78,0xF8,0x7F,0xF0,0x9F,0x07,0xFE,0x83,0x0F,0xFF,0x00,
  0x77,0x3C,0x18,0x1C,0x70,0xF0,0xE1,0x3F,0xF1,0x9F,0x07,0xFE,0xE1,0x1F,0xFF,0xC3,
  0xF7,0x3C,0x38,0x0C,0x70,0xE0,0x87,0x8F,0xF1,0xC0,0x07,0x1E,0x70,0x3C,0xCF,0xE3,
  0xE1,0x7D,0x3C,0x0E,0x70,0xD0,0x1F,0xC0,0xF1,0xC0,0x03,0x1F,0x78,0x3C,0xCF,0xE3,
  0xE1,0x7D,0x3C,0x06,0xF0,0xB0,0xFF,0xF1,0xF0,0xC0,0x03,0x0F,0x78,0x3C,0xCF,0xF3,
  0xE0,0x7B,0x3E,0x06,0xF0,0x60,0xFF,0xFF,0xF0,0xC6,0x03,0xEF,0x3C,0x80,0xEF,0xF1,
  0xE0,0x7B,0x3E,0x03,0xF0,0xE1,0xFC,0xFF,0xF8,0xCF,0x03,0xFF,0x3C,0x80,0xFF,0xF0,
  0xE0,0x7B,0x7B,0x01,0xE0,0xC3,0xF9,0x7F,0x78,0xC0,0x03,0x0F,0x3C,0x80,0xF7,0xF1,
  0xE0,0xF9,0xF9,0x01,0xE0,0x83,0xE3,0x7F,0x78,0xE0,0x03,0x0F,0x3C,0xBC,0xE7,0xF1,
  0xE0,0xF9,0xF9,0x00,0xC0,0x0F,0x8F,0x3F,0x78,0xE0,0x81,0x0F,0x3C,0x9E,0xE7,0xF1,
  0xE0,0xF1,0xF8,0x00,0x80,0x3F,0x1E,0x00,0x78,0xE0,0x81,0x07,0x38,0x9E,0xE7,0xF1,
  0xF0,0xF0,0x78,0x00,0x80,0xFF,0xFF,0x00,0xF8,0xEF,0xBF,0xFF,0xF8,0xCF,0xE7,0xE1,
  0x7F,0x70,0x70,0x00,0x00,0xFF,0xFF,0x0F,0xF8,0xEF,0xBF,0xFF,0xE0,0xC3,0xE3,0x81,
  0x1F,0x70,0x30,0x00,0x00,0xFC,0xFF,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0xF8,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0xE0,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

void setup() {
  u8g.firstPage();
  do { draw_elecrow(); } while (u8g.nextPage());
  delay(2000);

  Wire.begin();
  RTC.begin();
  Serial.begin(9600);

  pinMode(relay1, OUTPUT);
  pinMode(relay2, OUTPUT);
  pinMode(relay3, OUTPUT);
  pinMode(relay4, OUTPUT);
  pinMode(pump, OUTPUT);
  pinMode(button, INPUT);
}

void loop() {
  read_value();
  water_flower();

  int reading = digitalRead(button);
  if (reading != lastButtonState) {
    lastDebounceTime = millis();
  }

  if ((millis() - lastDebounceTime) > debounceDelay) {
    if (millis() - lastDisplayUpdate >= displayInterval ||
        lastMoisture1 != moisture1_value || lastMoisture2 != moisture2_value ||
        lastMoisture3 != moisture3_value || lastMoisture4 != moisture4_value) {

      u8g.firstPage();
      do {
        if (reading == HIGH) {
          drawTH();        // Now shows % moisture
          drawflower();
        } else {
          drawtime();
          u8g.drawStr(8, 55, "www.elecrow.com");
        }
      } while (u8g.nextPage());

      lastDisplayUpdate = millis();
      lastMoisture1 = moisture1_value;
      lastMoisture2 = moisture2_value;
      lastMoisture3 = moisture3_value;
      lastMoisture4 = moisture4_value;
    }
  }
  lastButtonState = reading;
}

void read_value() {
  // YOUR CALIBRATED VALUES
  const int AIR_VALUE = 640;           // Dry in air
  const int WATER_VALUE = 358;         // Fully submerged
  const int NO_SENSOR_THRESHOLD = 800;

  const int num_samples = 10;
  const int sample_delay = 5;

  auto readSensor = [&](int pin, int &raw, int &percent, bool &active, int index) {
    long total = 0;
    int minVal = 1023, maxVal = 0;
    for (int i = 0; i < num_samples; i++) {
      int val = analogRead(pin);
      total += val;
      if (val < minVal) minVal = val;
      if (val > maxVal) maxVal = val;
      delay(sample_delay);
    }
    raw = total / num_samples;
    int range = maxVal - minVal;

    if (raw > NO_SENSOR_THRESHOLD || range > 100) {
      active = false;
      percent = 0;
    } else {
      active = true;
      percent = map(raw, AIR_VALUE, WATER_VALUE, 0, 100);
      percent = constrain(percent, 0, 100);
    }
  };

  readSensor(moisture1, moisture1_raw, moisture1_value, sensor_active[0], 0);
  readSensor(moisture2, moisture2_raw, moisture2_value, sensor_active[1], 1);
  readSensor(moisture3, moisture3_raw, moisture3_value, sensor_active[2], 2);
  readSensor(moisture4, moisture4_raw, moisture4_value, sensor_active[3], 3);
}

void water_flower() {
  static unsigned long lastRelayTime = 0;
  if (millis() - lastRelayTime < 50) return;
  lastRelayTime = millis();

  auto controlRelay = [&](bool active, int percent, int relayPin, int &relayFlag) {
    if (active && percent < 40) {
      digitalWrite(relayPin, HIGH);
      relayFlag = 1;
      if (pump_state_flag == 0) {
        digitalWrite(pump, HIGH);
        pump_state_flag = 1;
      }
    } else if (active && percent > 55) {
      digitalWrite(relayPin, LOW);
      relayFlag = 0;
    }
  };

  controlRelay(sensor_active[0], moisture1_value, relay1, relay1_state_flag);
  controlRelay(sensor_active[1], moisture2_value, relay2, relay2_state_flag);
  controlRelay(sensor_active[2], moisture3_value, relay3, relay3_state_flag);
  controlRelay(sensor_active[3], moisture4_value, relay4, relay4_state_flag);

  bool anyActive = (relay1_state_flag || relay2_state_flag || relay3_state_flag || relay4_state_flag);
  if (!anyActive && pump_state_flag == 1) {
    digitalWrite(pump, LOW);
    pump_state_flag = 0;
  }
}

void draw_elecrow(void) {
  u8g.setFont(u8g_font_gdr9r);
  u8g.drawStr(8, 55, "www.elecrow.com");
  u8g.drawXBMP(0, 5, 128, 32, bitmap_logo);
}

void drawtime(void) {
  DateTime now = RTC.now();
  if (!RTC.isrunning()) {
    u8g.setFont(u8g_font_6x10);
    u8g.setPrintPos(5, 20);
    u8g.print("RTC is NOT running!");
    RTC.adjust(DateTime(__DATE__, __TIME__));
  } else {
    int x = 5;
    u8g.setFont(u8g_font_7x13);
    u8g.setPrintPos(x, 11); u8g.print(now.year(), DEC);
    u8g.setPrintPos(x + 80, 11); u8g.print(daysOfTheWeek[now.dayOfTheWeek()]);
    u8g.setPrintPos(x + 28, 11); u8g.print("/");
    u8g.setPrintPos(x + 33, 11); u8g.print(now.month(), DEC);
    u8g.setPrintPos(x + 47, 11); u8g.print("/");
    u8g.setPrintPos(x + 53, 11); u8g.print(now.day(), DEC);

    u8g.setFont(u8g_font_8x13);
    x = 35;
    u8g.setPrintPos(x, 33); u8g.print(now.hour(), DEC);
    u8g.setPrintPos(x + 15, 33); u8g.print(":");
    u8g.setPrintPos(x + 21, 33); u8g.print(now.minute(), DEC);
    u8g.setPrintPos(x + 36, 33); u8g.print(":");
    u8g.setPrintPos(x + 42, 33); u8g.print(now.second(), DEC);
  }
}

void drawflower(void) {
  if (sensor_active[0]) u8g.drawXBMP(0,  0, 32, 30, moisture1_value < 40 ? bitmap_bad : bitmap_good);
  if (sensor_active[1]) u8g.drawXBMP(32, 0, 32, 30, moisture2_value < 40 ? bitmap_bad : bitmap_good);
  if (sensor_active[2]) u8g.drawXBMP(64, 0, 32, 30, moisture3_value < 40 ? bitmap_bad : bitmap_good);
  if (sensor_active[3]) u8g.drawXBMP(96, 0, 32, 30, moisture4_value < 40 ? bitmap_bad : bitmap_good);
}

// Now displays moisture percentage (%)
void drawTH(void) {
  u8g.setFont(u8g_font_7x14);

  auto drawOne = [&](int idx, int labelX, int valX, int percentX, int naX, int percent) {
    u8g.setPrintPos(labelX, 60);
    u8g.print("A"); u8g.print(idx);

    if (sensor_active[idx]) {
      char buf[4];
      sprintf(buf, "%2d", percent);  // 2 digits + space for alignment
      u8g.drawStr(valX, 45, buf);
      u8g.drawStr(percentX, 45, "%");
    } else {
      u8g.drawStr(naX, 45, "N/A");
    }
  };

  drawOne(0, 9,   10, 28, 10, moisture1_value);
  drawOne(1, 41, 42, 60, 42, moisture2_value);
  drawOne(2, 73, 74, 92, 74, moisture3_value);
  drawOne(3, 105,106,124,106, moisture4_value);
}
